---
title: 《你所不知道的JavaScript》读书笔记
categories: "每天学一点js"
tags: 
     - js
---

# 上卷

### Chapter one:

** 变量提升：在JavaScript中，函数及变量的声明都将被提升到函数的最顶部。变量可以先使用再声明；但如果变量已经初始化如：var x = 5; 则不会被提升。但是为了避免出现一些问题，通常我们在每个作用域开始前声明这些变量。在JavaScript严格模式下，不允许使用未声明的变量。 ** 

    test one -----------------
    
    function foo(a){
        var b = a;
        return a + b;
    }
    var c = foo(2)
    
    分析：
    这个例子中会执行三次LHS: 1️⃣c = .... 2️⃣a = 2(隐式变量分配)️  3️⃣b =...
    这个例子中会执行四次RHS: 1️⃣foo(2)   2️⃣..=a    3️⃣ a+..    4️⃣.. +b

** 当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。当抵达全局作用域时，无论找到还是没找到，查找过程都会停止。 **

在非严格模式下，LHS 调用查找不到变量时会自动隐式地创建一个全局变量，RHS查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出ReferenceError。如果统领过了作用于判别，但做出了一些不合理的操作，引擎会抛出另外一种类型的异常——TypeError。ReferenceError与作用域判别失败相关，而TypeError则代表作用域判别成功但是对结果的操作是非法或不合理的。

### Chapter two:

作用域查找始终从运行时所处的最内部作用域开始，逐级向外进行，直到遇见第一个标识符为止。在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”。全局变量会自动成为全局对象的属性，通过 window.a 可以访问那些被同名变量所遮蔽的全局变量，通过这种方式可以访问那些被同名变量所遮蔽的全局变量，但非全局的变量如果被遮蔽，无论如何也无法被访问。

欺骗词法

    1.eval()接收一个字符串为参数，并将其内容视为好像就书写时就存在在这个程序，这个位置的代码。
    2.with()根据你传递给它的对象凭空创建一下全新的词法作用域。
    

JS引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底 是什么。如果代码中大量使用 eval(..) 或 with(..)，那么运行起来一定会变得非常慢。

### Chapter three:

通过函数中的作用域，我们可以将一段代码放在函数中，这样这段代码的作用域即是当前函数，可以有效地“隐藏”这段代码！

要在一个函数内部具体实现的私有内容不需要定义在外部作用域，这给予了外部作用域对于内部私有内容的访问权限，其实十分没有必要，而且可能是“危险”的，因为它们有可能被有意无意地以非预期的方式使用。

    function doSomething(a) {
        b = a + doSomethingElse( a * 2 );
        console.log( b * 3 );
    }
    function doSomethingElse(a) { return a - 1;
    }
    var b;
    doSomething( 2 ); // 15
    
    //以上做法不是很好
    
    function doSomething(a) { 
        function doSomethingElse(a) {
             return a - 1;  
        }
        var b;
        b = a + doSomethingElse( a * 2 );
        console.log( b * 3 );
    }
    doSomething( 2 ); // 15 
  
    //以上做法很好的将具体内容私有化，无法从外部访问，棒！  
    
隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。

** 通过函数将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容，但是如果将这个包装函数声明在外层作用域中再进行调用，就污染了所在的作用域，其次，必须显式地通过函数名调用才能使之运行，为了解决这个问题，我们可以这样一起声明调用包装函数：(function foo(){ .. })作为函数表达式意味着foo只能在..所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。 ** 

 函数表达式是可以匿名的，但函数声明不可以省略函数名。匿名函数的几个缺点：
    
- 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。比如在递归中，另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
- 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明。

因此始终给函数表达式命名是最佳的解决方案,for example

     setTimeout( 
        function timeoutHandler() { // <-- 快看，我有名字了!             
         console.log( "I waited 1 second!" );
     }, 1000 );
        
立即执行函数表达式的两种写法如下，功能一致；

1️⃣ (function foo(){ .. })()
    
2️⃣ (function(){ .. }())
       
       
在块作用域中，变量的声明应该距离使用的地方越近越好，并最大限度的本地化。

用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。在抛出异常时，作用域也仅仅在catch中，为了避免静态检查工具对重复变量进行检查，可以将catch的参数命名为err1、err2....

在 ES6 中引入了 let 关键字(var 关键字的表亲)，用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块 中。const创建的块作用域变量，其值是固定的，之后任何试图修改的操作都会引起错误 ❎

### Chapter four

先有鸡还是先有蛋？
答：现有声明后有赋值


编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

** 提升：变量和函数的声明会被提升，它们的代码中执行的位置会被“移动” **

one

    a = 2;                          var a;
    var a;                  =>      a = 2;
    console.log( a );               console.log( a );
    // 输出2
   
 
two

    console.log(a);                var a;
    var a=2;              =>       console.log(a)
                                   a=2;
    //输出undefined            
 
 three
 
    foo();
    function foo() {
        console.log( a ); // undefined 
        var a = 2;
    }
    
    ⬇️
    
    function foo() {
        var a;
        console.log( a ); // undefined
        a = 2; 
    }
    foo();

** 函数声明会被提升，但是函数表达式却不会被提升。 **

    foo(); // TypeError
    bar(); // ReferenceError
    var foo = function bar() { // ...
    };
    
    ⬇️
    
    var foo;
    foo(); // TypeError
    bar(); // ReferenceError
    foo = function() {
    var bar = ...self... // ...
    }
    
    
** 函数会首先被提升，然后才是变量。 **
重复的var声明会被忽略掉，但是出现在后面的函数声明还是可以覆盖前面的

### Chapter five

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

模块有两个主要特征:

为创建内部作用域而调用了一个包装函数;
包装函数的返回值必须至少包括一个对内部函数的引用,这样就会创建涵盖整个包装函数内部作用域的闭包。
